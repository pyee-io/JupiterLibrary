<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: jupiter.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: jupiter.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import utils from './utils.js'; // generic import, requires "utils" namespace to be used in code
import lookups from './lookups.js'; // import lookups as a single object

/**
 * Represents a Jupiter document.
 * @constructor
 * @param {Object} doc - The document object itself
 * @property {string} id - Unique identifier (ThoughtTrace)
 * @property {string} name - Document name
 *
 * @property {string} document_type - Document Type
 * @property {string} project_id - Project ID
 * @property {string} project_name - Project Name
 * @property {Date} effective_date - Effective date of the document
 *
 * @property {Array} agreement_terms - array of potential agreement terms
 * @property {Date} agreement_terms.start_date - start date of lease term
 * @property {Date} agreement_terms.end_date - end date of lease term
 *
 * @property {Array} periodic_term_payment_models - array of periodic payment models
 * @property {Array} tags - array of tags
 */
class JupiterDoc {
    constructor(doc, factTypes, docTypes = [], tags = []) {
        // remove clutter
        this.cleanDoc(doc);
        utils.addFactandFieldNames(doc, factTypes);

        // set initial properties
        this.rawDoc = doc;
        this.id = doc.id;
        this.name = doc.name;

        // set fact-based properties and arrays
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        // Document Type
        var docType = docTypes.find((x) => x.id === doc.documentTypeId);
        this.document_type = docType ? docType.name : null;

        // Agreement ID
        this.agreement_id = utils.extractFactValue(
            doc,
            utils.getFactTypeId('Agreement ID', factTypes),
            utils.getFactFieldId('Agreement ID', 'Agreement ID', factTypes),
            'string'
        );

        // Project ID
        this.project_id = utils.extractFactValue(
            doc,
            utils.getFactTypeId('Project ID', factTypes),
            utils.getFactFieldId('Project ID', 'Project ID', factTypes),
            'string'
        );

        // Project Name
        this.project_name = utils.extractFactValue(
            doc,
            utils.getFactTypeId('Project Name', factTypes),
            utils.getFactFieldId('Project Name', 'Project Name', factTypes),
            'string'
        );

        // Grantor/Lessor - Multi-instance fact
        this.grantor = utils.extractMultiFactValues(doc, utils.getFactTypeId('Grantor/Lessor', factTypes));

        // Effective Date
        this.effective_date = utils.extractFactValue(
            doc,
            utils.getFactTypeId('Effective Date', factTypes),
            utils.getFactFieldId('Effective Date', 'Effective Date', factTypes),
            'date'
        );

        // Amendment Date
        this.amendment_date = utils.extractFactValue(
            doc,
            utils.getFactTypeId('Amendment Date', factTypes),
            utils.getFactFieldId('Amendment Date', 'Amendment Date', factTypes),
            'date'
        );

        // Leased Acres
        this.leased_acres = utils.extractFactValue(
            doc,
            utils.getFactTypeId('Leased Acres', factTypes),
            utils.getFactFieldId('Leased Acres', 'Leased Acres', factTypes),
            'number'
        );

        // Purchase Price
        this.full_purchase_price = utils.extractFactValue(
            doc,
            utils.getFactTypeId('Full Purchase Price', factTypes),
            utils.getFactFieldId('Full Purchase Price', 'Full Purchase Price', factTypes),
            'number'
        );

        // Closing Date
        this.closing_date = utils.extractFactValue(
            doc,
            utils.getFactTypeId('Closing Date', factTypes),
            utils.getFactFieldId('Closing Date', 'Closing Date', factTypes),
            'date'
        );

        // Operational Details
        this.operational_details = utils.extractFactMultiFields(doc, utils.getFactTypeId('Operational Details', factTypes));

        // Agreement Terms
        this.agreement_terms = utils.extractMultiFactValues(doc, utils.getFactTypeId('Agreement Term', factTypes));

        // Option Terms
        //this.option_terms = utils.extractMultiFactValues(doc, utils.getFactTypeId('Option Term', factTypes));

        // Periodic Payment Models (term based)
        this.periodic_term_payment_models = utils.extractMultiFactValues(doc, utils.getFactTypeId('Payment Model - Periodic Term Based', factTypes));

        // Peroidic Payment Models (date based)
        this.periodic_date_payment_models = utils.extractMultiFactValues(doc, utils.getFactTypeId('Payment Model - Periodic Date Based', factTypes));

        // One Time Payment Models
        this.one_time_payment_models = utils.extractMultiFactValues(doc, utils.getFactTypeId('Payment Model - One Time', factTypes));

        // Tags
        this.tags = this.getTags(tags);

        // Review Status
        this.review_status = utils.extractFactValue(
            doc,
            utils.getFactTypeId('Review Status', factTypes),
            utils.getFactFieldId('Review Status', 'Review Status', factTypes),
            'string'
        );

        // Review Status Notes
        this.review_status_notes = utils.extractFactValue(
            doc,
            utils.getFactTypeId('Review Status', factTypes),
            utils.getFactFieldId('Review Status', 'Notes', factTypes),
            'string'
        );

        // calculate agreement group
        this.agreement_group = this.calcAgreementGroup();

        // calculate lease term dates
        this.calcAgreementTermDates(this.agreement_terms, this.effective_date, this.operational_details);

        // deprecated - these should all be in agreement terms
        //this.calcOptionTermDates(this.option_terms, this.effective_date);
    }

    /**
     * calc agreement ID
     */
    calcAgreementGroup() {
        // only calculate for completed docs
        if (!this.grantor[0] || !this.review_status === 'Complete') {
            return null;
        }
        // check other required fields, and exclude any known amendments

        if (this.project_id &amp;&amp; this.project_name &amp;&amp; this.document_type &amp;&amp; !this.amendment_date) {
            return `${lookups[this.document_type]} - ${this.project_name} - ${this.nicknameGrantor(this.grantor[0]['grantor/lessor_name'])} - ${
                this.project_id
            }`;
        }

        return null;
    }

    /**
     * creates array of tag names from tag ids
     */
    getTags(tags) {
        var result = [];
        this.rawDoc.tagIds.forEach((id) => {
            var tag = tags.find((x) => x.id === id);

            if (tag) {
                result.push(tags.find((x) => x.id === id).name);
            }
        });

        return result;
    }

    /**
     * calculates the term dates from the given facts
     * This function mutates lease term objects and creates calculated properties
     */
    calcAgreementTermDates(agreementTerms, effectiveDate, opDetails) {
        // exit if no effectiveDate
        if (!effectiveDate) {
            return;
        }

        opDetails = opDetails || {};

        agreementTerms
            .sort((a, b) => a.term_ordinal - b.term_ordinal)
            .forEach((term, index) => {
                // check opDetails for actual construction start date
                // only set on non-extension terms for construction and operations
                if (term.term_type === 'Construction' &amp;&amp; !term.extension &amp;&amp; opDetails.construction_commencement) {
                    term.start_date = opDetails.construction_commencement;
                } else if (term.term_type === 'Operations' &amp;&amp; !term.extension &amp;&amp; opDetails.operations_commencement) {
                    term.start_date = opDetails.operations_commencement;
                } else {
                    // start day after previous term end, or if no previous term, use effective date
                    term.start_date = agreementTerms[index - 1] ? agreementTerms[index - 1].end_date.plus({ days: 1 }) : effectiveDate;
                }
                // add a text version pre-formatted
                term.start_date_text = term.start_date.toFormat('MM/dd/yyyy');

                // calculated end-date, will be tested against opDates later
                // end one day prior to the Nth anniversary, or on operationalDetails termination date, whichever is sooner
                term.end_date = utils.getEarliestDateTime(
                    opDetails.termination,
                    term.start_date.plus({ years: term.term_length_years }).plus({ days: -1 })
                );

                // on non-construction and non-operational terms, check to see if they are cut short, or totally removed by operational dates
                if (term.term_type !== 'Construction' &amp;&amp; term.term_type !== 'Operations') {
                    var firstOpsDate = utils.getEarliestDateTime(opDetails.construction_commencement, opDetails.operations_commencement);

                    if (firstOpsDate) {
                        // check start date
                        if (term.start_date.ts >= firstOpsDate.ts) {
                            // cancel the whole term
                            term.cancelled_by_ops = true;
                        } else if (term.end_date.ts >= firstOpsDate.ts) {
                            // cut the term short
                            term.end_date = firstOpsDate.plus({ days: -1 });
                        }
                    }
                } else if (term.term_type === 'Construction' &amp;&amp; opDetails.operations_commencement) {
                    // check construction term against operations commencement date
                    if (term.end_date.ts >= opDetails.operations_commencement.ts) {
                        term.end_date = opDetails.operations_commencement.plus({ days: -1 });
                    }
                }

                term.end_date_text = term.end_date.toFormat('MM/dd/yyyy');

                // calculate previous periods on same payment model for periodic escalation
                // NOTE: this will not continue periodic escalations across payment models
                term.previous_escalation_periods = agreementTerms
                    .filter((x) => x.term_ordinal &lt; term.term_ordinal &amp;&amp; x.payment_model === term.payment_model)
                    .reduce((accumulator, t) => accumulator + t.term_length_years, 0);

                // calculate perevious terms for term escalation
                term.previous_terms = agreementTerms.filter(
                    (x) => x.term_ordinal &lt; term.term_ordinal &amp;&amp; x.payment_model === term.payment_model
                ).length;
            });
    }

    /**
     * calculates base periodic payment for a given model
     * largest of all possible ways to calculate payment
     */
    periodicBasePayment(model, op_details, compounding_escalation, term_escalation_rate, term_escalation_amount, previous_terms, leased_acres) {
        if (!model) {
            return 0;
        }

        // set defaults if no provided
        if (!op_details) {
            op_details = {
                mw: 0,
                inverter_count: 0,
                inverter_rating_mvas: 0,
            };
        }

        // calculate max payment from different methods
        var base = Math.max(
            model.minimum_payment ?? 0,
            (model.payment_per_mw ?? 0) * (op_details.mw ?? 0),
            (op_details.inverter_count ?? 0) * (op_details.inverter_rating_mvas ?? 0) * (model.payment_per_mva ?? 0),
            model.flat_payment_amount ?? 0,
            (model.payment_per_acre ?? 0) * (leased_acres ?? 0)
        );

        // apply amount escalation
        base = base + ((term_escalation_amount ?? 0) * previous_terms ?? 0);

        // apply rate escalation
        if (compounding_escalation) {
            base = utils.calculateCompoundingGrowth(base, (term_escalation_rate ?? 0) / 100, previous_terms ?? 0);
        } else {
            base = utils.calculateGrowth(base, (term_escalation_rate ?? 0) / 100, previous_terms ?? 0);
        }

        return base;
    }

    /***
     * assign model to given lease term
     */

    termPaymentModel(term, paymentModels) {
        // exit if there are no models
        if (!paymentModels || paymentModels.length === 0) {
            return null;
        }

        const model_name = term.payment_model ?? term.term_type;
        // return model if name matches, or first model if no name
        return model_name ? paymentModels.find((x) => x.model_type === model_name) : paymentModels[0];
    }

    /***
     * calculate payment period end
     */
    calcPaymentPeriodEnd(start_date, frequency, prorated, term_end) {
        var payment_period_end;

        if (prorated) {
            // pro-rated payment dates
            if (frequency === 'Annually') {
                payment_period_end = new luxon.DateTime.local(start_date.year, 12, 31);
            } else if (frequency === 'Quarterly') {
                payment_period_end = new luxon.DateTime.local(start_date.year, start_date.month + 3, 1).minus({ days: 1 });
            } else if (frequency === 'Monthly') {
                payment_period_end = new luxon.DateTime.local(start_date.year, start_date.month, 1).plus({ months: 1 }).minus({ days: 1 });
            }
        } else {
            // anniversary payment dates
            if (frequency === 'Annually') {
                payment_period_end = start_date.plus({ years: 1 }).minus({ days: 1 });
            } else if (frequency === 'Quarterly') {
                payment_period_end = start_date.plus({ months: 3 }).minus({ days: 1 });
            } else if (frequency === 'Monthly') {
                payment_period_end = start_date.plus({ months: 1 }).minus({ days: 1 });
            }
        }

        // if payment period end is after term end, return term end
        return payment_period_end > term_end ? term_end : payment_period_end;
    }

    /***
     * calculate periodic payments for a given term
     */

    calcPeriodicPaymentsForTerm(term, op_details, paymentModels, leased_acres, grantor, project_id) {
        // exit if term is cancelled by operations starting, or there are no grantors listed
        if (term.cancelled_by_ops || grantor.length === 0) {
            return null;
        }

        const payments = [];

        // get payment model for this term
        const model = this.termPaymentModel(term, paymentModels);
        const periodic_payment = this.periodicBasePayment(
            model,
            op_details,
            term.compounding_escalation,
            term.escalation_rate,
            term.escalation_amount,
            term.previous_terms,
            leased_acres
        );

        // exit if no model, or start/end dates
        if (!model || !term.start_date || !term.end_date) {
            return null;
        }

        // initialize variables
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        var i = 0;
        var prorata_factor;
        var term_payment_delay_days = term.term_payment_delay_days ?? 0;
        var payment_period_start = term.start_date.plus({ days: term.term_payment_delay_days });
        var payment_date;
        var payment_period_end;

        // var term_escalation_rate = term.escalation_rate ?? 0;
        var periodic_escalation_rate = model.periodic_escalation_rate ?? 0;

        // calc first payment date for term
        switch (term.first_payment_start) {
            case 'Start with Term (plus applicable lag)':
                payment_date = term.start_date.plus({ days: term_payment_delay_days });
                break;
            case 'Start next Jan 1 after Term commencement':
                payment_date = new luxon.DateTime.local(term.start_date.year + 1, 1, 1).plus({ days: term_payment_delay_days });
                break;
            case 'Start 1st of month after commencement':
                payment_date = new luxon.DateTime.local(payment_period_start.year, payment_period_start.month, 1).plus({ months: 1 });
                break;
            // add more cases as they arise
            default:
                payment_date = term.first_payment_date ?? term.start_date;
        }

        // loop through remaining payments
        while (payment_period_start &lt; term.end_date) {
            // calculate payment period end date
            payment_period_end = this.calcPaymentPeriodEnd(payment_date, model.payment_frequency, model.prorated_first_period, term.end_date);

            if (!payment_period_end) return;

            // calculate pro rata periods
            if (model.payment_frequency === 'Annually') {
                prorata_factor = utils.round(payment_period_end.plus({ days: 1 }).diff(payment_period_start, 'years').years, 4);
            } else if (model.payment_frequency === 'Quarterly') {
                prorata_factor = utils.round(payment_period_end.plus({ days: 1 }).diff(payment_period_start, 'quarters').quarters, 4);
            } else if (model.payment_frequency === 'Monthly') {
                prorata_factor = utils.round(payment_period_end.plus({ days: 1 }).diff(payment_period_start, 'months').months, 4);
            }

            // handle discrepancy between payment frequency and escalation frequency
            // set up index variable and ratio factors
            var periodic_escalation_frequency_index;
            var ratioFactors = {
                Annually: 1,
                Quarterly: 4,
                Monthly: 12,
            };

            // determine an index difference between escalation frequency and payment frequency
            if (model.payment_frequency &amp;&amp; model.periodic_escalation_frequency) {
                periodic_escalation_frequency_index = ratioFactors[model.payment_frequency] / ratioFactors[model.periodic_escalation_frequency];
            } else {
                periodic_escalation_frequency_index = 1;
            }

            // loop through grantors and add payments per payee according to their split
            grantor.forEach((g) => {
                payments.push({
                    project_id: project_id,
                    payment_index: i,
                    payee: this.nicknameGrantor(g['grantor/lessor_name']),
                    payment_date: payment_date.toLocaleString(),
                    grace_days: i === 0 ? term.first_payment_grace_days ?? 0 : term.subsequent_payment_grace_days ?? 0,
                    payment_period_start: payment_period_start.toLocaleString(),
                    payment_period_end: payment_period_end.toLocaleString(),
                    prorata_factor: prorata_factor,
                    applicable_to_purchase: model.applicable_to_purchase,
                    // base_payment: utils.round(periodic_payment * (1 + term_escalation_rate / 100), 4),
                    total_payment_amount:
                        utils.calculateCompoundingGrowth(
                            periodic_payment * ((g.payment_split ?? 100) / 100),
                            periodic_escalation_rate / 100,
                            Math.floor(i / periodic_escalation_frequency_index)
                        ) * prorata_factor,
                });
            });

            payment_period_start = payment_period_end.plus({ days: 1 });
            payment_date = payment_period_end.plus({ days: 1 });
            i++;
        }

        payments.sort((a, b) => a.payment_date - b.payment_date);

        return payments;

        // calc total payments for whole term
        //term.cumulative_payment_amount = payments.reduce((a, b) => a + b.total_payment_amount, 0);
    }

    /***
     * calc payments on all terms for the lease
     */
    calcAllTermPayments() {
        // calc payments in each term
        // and mutate the term object to set value of periodic_payments array
        this.agreement_terms.forEach((term) => {
            if (this.periodic_term_payment_models) {
                term.periodic_payments = this.calcPeriodicPaymentsForTerm(
                    term,
                    this.operational_details,
                    this.amended_periodic_term_payment_models ?? this.periodic_term_payment_models,
                    this.amended_leased_acres ?? this.leased_acres,
                    this.grantor,
                    this.project_id
                );
            }
        });
    }

    calcPeriodicDatePayments() {
        var periodic_date_payments = [];

        this.periodic_date_payment_models.forEach((model) => {
            // return null if missing required fields
            if (!model.start_date || !model.end_date || !model.payment_amount || !model.frequency) return;

            // iterating variables
            var payment_date = model.start_date;
            var period = 1;
            var payment_amount = 0;

            // loop until end date is reached
            while (payment_date &lt;= model.end_date) {
                // apply escalation as needed
                if (model.compounding_escalation) {
                    payment_amount = utils.calculateCompoundingGrowth(model.payment_amount, (model.escalation_rate ?? 0) / 100, period);
                } else {
                    payment_amount = utils.calculateGrowth(model.payment_amount, (model.escalation_rate ?? 0) / 100, period);
                }

                // TODO: these are not yet being split among all grantors - it all goes to the first one, or to the payee if specified

                // create payment object
                var payment = {
                    model_id: model.id,
                    payment_date: payment_date.toLocaleString(),
                    payment_type: model.payment_type,
                    payment_amount: payment_amount,
                    payee: model.payee ?? this.nicknameGrantor(this.grantor[0]['grantor/lessor_name']),
                    applicable_to_purchase: model.applicable_to_purchase,
                    refundable: model.refundable,
                };

                // add payment to array
                periodic_date_payments.push(payment);

                // increment period
                period++;

                // increment payment date based on model frequency
                if (model.frequency === 'Annually') {
                    payment_date = payment_date.plus({ years: 1 });
                } else if (model.frequency === 'Quarterly') {
                    payment_date = payment_date.plus({ months: 3 });
                } else if (model.frequency === 'Monthly') {
                    payment_date = payment_date.plus({ months: 1 });
                } else {
                    // if frequency doesn't match one of those options return - we can't get into an infinite loop
                    // this can probably go above so we don't post any payments...
                    return;
                }
            }
        });

        // all models, all loops complete, mutate doc object to contain results
        this.periodic_date_payments = periodic_date_payments;
    }

    /**
     * calc one-time payments (including purchase price)
     */
    calcOneTimePayments() {
        // exit if no one-time models
        if (!this.one_time_payment_models.length > 0) return;

        var one_time_payments = [];

        // create payment object for all models
        this.one_time_payment_models.forEach((model) => {
            // if payment date is not specified, use effective date
            var payment_date = model.payment_due ?? this.effective_date;

            one_time_payments.push({
                // payment is due on fixed date, or on the effective date
                payment_date: payment_date.toLocaleString(),
                payment_type: model.payment_type,
                payment_amount: model.payment_amount,
                applicable_to_purchase: model.applicable_to_purchase,
                refundable: model.refundable,
            });
        });

        // calculate how mcuh of the purchase price has already been paid
        var previous_applicable_payments = one_time_payments.filter((x) => x.applicable_to_purchase).reduce((a, b) => a + b.payment_amount, 0);

        // loop through agreement terms and find all payments applicable to purchase price
        if (this.agreement_terms.length > 0) {
            this.agreement_terms.forEach((term) => {
                if (term.periodic_payments) {
                    // add any payments applicable to purchase price
                    previous_applicable_payments +=
                        term.periodic_payments.filter((x) => x.applicable_to_purchase).reduce((a, b) => a + b.total_payment_amount, 0) ?? 0;
                }
            });
        }

        // filter dated payments and find all payments applicable to purchase price
        if (this.periodic_date_payments) {
            previous_applicable_payments +=
                this.periodic_date_payments.filter((x) => x.applicable_to_purchase).reduce((a, b) => a + b.payment_amount, 0) ?? 0;
        }

        if (this.full_purchase_price > 0) {
            // create payment object for purchase price
            one_time_payments.push({
                // Defaults to closing date, or last term end date if no closing date
                // ?? if no agreement terms, this won't work... may need to also default to effective date if no terms exist ??
                payment_date: this.closing_date
                    ? this.closing_date.toLocaleString()
                    : this.agreement_terms.sort((a, b) => b.end_date - a.end_date)[0].end_date.toLocaleString(),
                payment_type: 'Purchase Price',
                // purchase payment will subtract all payments applicable to purchase price
                payment_amount: this.full_purchase_price - previous_applicable_payments,
                applicable_to_purchase: true,
                refundable: false,
            });
        }

        // mutate doc object to store one time payment array
        this.one_time_payments = one_time_payments;
    }

    /**
     * load amendments &amp; create new properties to store them
     */

    processAmendments(allDocs) {
        const amendments = allDocs.filter((x) => this.agreement_id &amp;&amp; x.agreement_id === this.agreement_id &amp;&amp; x.amendment_date &amp;&amp; x.id !== this.id);
        if (amendments) {
            // sort amendments by amendment date, adding an ordinal property
            amendments
                .sort((a, b) => {
                    return new Date(a.amendment_date) - new Date(b.amendment_date);
                })
                .map((x) => (x.amendment_ordinal = amendments.indexOf(x) + 1));

            // check each amendment for new values
            // newer amendments overwrite older values
            amendments.forEach((amendment) => {
                // leased acres
                // only write if different from parent doc
                if (amendment.leased_acres &amp;&amp; amendment.leased_acres !== this.leased_acres) {
                    this.amended_leased_acres = amendment.leased_acres;
                }

                // lease terms
                if (amendment.agreement_terms &amp;&amp; amendment.agreement_terms.length > 0) {
                    this.amended_agreement_terms = amendment.agreement_terms;
                }

                // periodic payment models
                if (amendment.periodic_term_payment_models &amp;&amp; amendment.periodic_term_payment_models.length > 0) {
                    this.amended_periodic_term_payment_models = amendment.periodic_term_payment_models;
                }
            });

            // re-calculate payments based on amended values
            if (this.agreement_terms) {
                this.calcAllTermPayments();
            }
        }
    }

    /**
     * Nickname lessors
     */

    nicknameGrantor(longName) {
        // create array of indexes
        var indexes = [];

        // find first instance of "and" or a "," in the name
        // repeat for anything we want to search for, and add it to the list
        longName.toLowerCase().indexOf(' and ') > 0 ? indexes.push(longName.toLowerCase().indexOf(' and ')) : null;
        longName.toLowerCase().indexOf(', ') > 0 ? indexes.push(longName.toLowerCase().indexOf(',')) : null;

        // return whole string if no "stoppers" found
        if (indexes.length === 0) {
            return longName;
        }

        var index = Math.min(...indexes);

        // return the substring up to to the index
        return longName.substring(0, index);
    }

    /**
     * clean unused fields from document object
     * just makes debugging easier
     */
    cleanDoc(doc) {
        // fields to delete
        const fields = [
            'archivedBy',
            'archivedOn',
            'highlightedText',
            'pageManipulationStatus',
            'processingStatus',
            'pages',
            'securityLabelId',
            'sourceDocumentId',
            'sourceDocumentName',
            'pageCount',
            'thoughts',
            'userIds',
        ];

        fields.forEach((field) => {
            delete doc[field];
        });

        return doc;
    }
}

export default JupiterDoc;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="JupiterDoc.html">JupiterDoc</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.0</a> on Fri Mar 03 2023 17:10:29 GMT-0600 (Central Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
